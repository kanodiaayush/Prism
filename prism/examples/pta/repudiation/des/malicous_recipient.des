#no update for variables
{ # send a request (suppose always does this)
init
	node start; y=0
	[ 
	req||tran  wait; y=0; null; 1.0
	 ] 
}
{ # wait for message
	node wait; true
	[ 
	message||tran  ack; true; null ; 1
	 ] 
	[ 
	finished||tran done; true; null ; 1
	 ] 
}
{ # send ack (need to decide on time bound here?)
	node ack; true
	[ 
	ack||tran  wait; true; null ; 1.0
	 ]
	[ # decide to try and decode the message (with a time out of 1 time unit)
	tran decode1; true; y=0 ; 1.0
	]
	[ # decide to try and decode the message (with a time out of 3 time units)
	tran decode2; true; y=0 ; 1.0
	]
	[ # decide to terminate_early
	tran terminate; true; null ; 1.0
	]

}
{ # finished correctly
	node done; true
	[ 
	] 
}
{ # terminated early
	node terminate; true
	[
	] 
}
{ # try and decode message with timeout of 1
	node decode1; y<=1
	[
	tran decode; y=1; y=0 ; 0.01 # successfully decode
	tran ack; y=1; y=0 ; 0.99 # time out (so back to ack)
	]
}
{ # try and decode message with timeout of 4
	node decode2; y<=3
	[
	tran decode; y=3; y=0 ; 0.05 # successfully decode
	tran ack; y=3; y=0 ; 0.95 # time out
	]
}
{ # decode the message
	node decode; y=0
	[	
	decode||tran decoded; y=0; null; 1
	]
}
{ # decoded (find out value)
	node decoded; y=0
	[
	decoded_random||tran random; y=0; null ; 1.0
	]
	[
	decoded_last||tran terminate; y=0; null ; 1.0 # if last then terminate early
	]
}
{ # decoded and random message (so send ack or terminate early)
	node random; y=0
	[
	ack||tran  wait; true; null ; 1.0 # send ack
	]
	[
	tran terminate; true; null ; 1.0 # terminate early
	]
*

